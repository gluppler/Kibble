/**
 * Multi-Factor Authentication (MFA) utilities for Kibble application.
 * 
 * This module provides TOTP (Time-based One-Time Password) functionality
 * using the otplib library. MFA adds an additional layer of security by
 * requiring users to provide a code from their authenticator app in addition
 * to their password.
 * 
 * Security Features:
 * - TOTP secrets generated server-side only (never exposed to client)
 * - Secrets stored encrypted in database
 * - Backup codes hashed with bcrypt before storage
 * - Time window tolerance for TOTP verification (accounts for clock skew)
 * - QR code generation for easy authenticator app setup
 * 
 * Buffer Security Policy:
 * - The unsafe Buffer() constructor is disallowed due to security risks (memory leaks)
 * - Only safe Buffer methods are used: Buffer.from(), Buffer.alloc(), or Buffer.allocUnsafe()
 * - crypto.randomBytes() returns a Buffer safely and is used for backup code generation
 * - All Buffer usage is validated by automated tests (see tests/mfa-buffer-security.test.ts)
 * 
 * @module lib/mfa-utils
 */

import "@/lib/suppress-buffer-deprecation";
import { authenticator } from "otplib";
import { toDataURL } from "qrcode";
import bcrypt from "bcrypt";
import crypto from "crypto";
import { logError } from "@/lib/logger";

/**
 * Generates a TOTP secret and QR code for MFA setup.
 * 
 * This function creates a new TOTP secret, generates a QR code that can be
 * scanned by authenticator apps, and creates backup recovery codes. The secret
 * should be stored in the database, and the QR code should be displayed to
 * the user for scanning.
 * 
 * Security:
 * - Secret is generated using cryptographically secure random bytes
 * - Backup codes are generated using secure random number generation
 * - QR code contains the OTP Auth URL format for standard compatibility
 * 
 * @param email - User's email address (used in QR code label)
 * @returns Promise resolving to object containing secret, QR code, and backup codes
 * 
 * @example
 * ```typescript
 * const { secret, qrCode, backupCodes } = await generateMFASecret(user.email);
 * // Store secret in database, display QR code to user, save backup codes securely
 * ```
 */
export async function generateMFASecret(email: string): Promise<{
  secret: string;
  qrCode: string;
  backupCodes: string[];
}> {
  // Generate secret (32 bytes, base32 encoded)
  const secret = authenticator.generateSecret();
  
  // Generate service name (from environment or default)
  const serviceName = process.env.MFA_SERVICE_NAME || "Kibble";
  
  // Create OTP Auth URL for QR code
  const otpAuthUrl = authenticator.keyuri(email, serviceName, secret);
  
  // Generate QR code as data URL
  const qrCode = await toDataURL(otpAuthUrl, {
    errorCorrectionLevel: "M",
    type: "image/png",
    width: 200,
    margin: 1,
  });
  
  // Generate backup recovery codes (10 codes, 8 characters each)
  const backupCodes = Array.from({ length: 10 }, () => {
    return crypto.randomBytes(4).toString("hex").toUpperCase();
  });
  
  return {
    secret,
    qrCode,
    backupCodes,
  };
}

/**
 * Verifies a TOTP code against a user's secret.
 * 
 * This function validates that the provided TOTP code matches what would be
 * generated by the user's authenticator app at the current time. It includes
 * time window tolerance to account for clock skew between devices.
 * 
 * Security:
 * - Validates token format (must be exactly 6 digits)
 * - Uses time window tolerance to handle clock differences
 * - Returns false on any error to prevent information leakage
 * 
 * @param token - TOTP code from user's authenticator app (6 digits)
 * @param secret - User's TOTP secret stored in database
 * @returns `true` if code is valid, `false` otherwise
 * 
 * @example
 * ```typescript
 * const isValid = verifyTOTP("123456", user.mfaSecret);
 * if (isValid) {
 *   // Allow access
 * }
 * ```
 */
export function verifyTOTP(token: string, secret: string): boolean {
  try {
    // Validate token format (6 digits)
    if (!/^\d{6}$/.test(token)) {
      return false;
    }
    
    // Verify with time window tolerance (default: Â±1 time step = 30 seconds)
    return authenticator.verify({
      token,
      secret,
    });
  } catch (error) {
    logError("Error verifying TOTP:", error);
    return false;
  }
}

/**
 * Hash backup codes for storage
 * 
 * @param codes - Array of backup codes
 * @returns Comma-separated string of hashed codes
 */
export async function hashBackupCodes(codes: string[]): Promise<string> {
  const hashedCodes = await Promise.all(
    codes.map((code) => bcrypt.hash(code, 10))
  );
  return hashedCodes.join(",");
}

/**
 * Verify a backup code
 * 
 * @param code - Backup code to verify
 * @param hashedCodes - Comma-separated string of hashed codes from database
 * @returns true if code is valid, false otherwise
 */
export async function verifyBackupCode(
  code: string,
  hashedCodes: string
): Promise<boolean> {
  if (!hashedCodes) {
    return false;
  }
  
  const codes = hashedCodes.split(",");
  
  // Try to match against any of the hashed codes
  for (const hashedCode of codes) {
    const isValid = await bcrypt.compare(code, hashedCode);
    if (isValid) {
      return true;
    }
  }
  
  return false;
}

/**
 * Remove a used backup code from the stored list
 * 
 * @param code - Backup code that was used
 * @param hashedCodes - Comma-separated string of hashed codes
 * @returns Updated comma-separated string with used code removed
 */
export async function removeBackupCode(
  code: string,
  hashedCodes: string
): Promise<string> {
  const codes = hashedCodes.split(",");
  const updatedCodes: string[] = [];
  
  for (const hashedCode of codes) {
    const isValid = await bcrypt.compare(code, hashedCode);
    if (!isValid) {
      // Keep codes that don't match (not the one being removed)
      updatedCodes.push(hashedCode);
    }
  }
  
  return updatedCodes.join(",");
}

/**
 * Validate TOTP code format
 * 
 * @param code - Code to validate
 * @returns true if format is valid (6 digits), false otherwise
 */
export function validateTOTPFormat(code: string): boolean {
  return /^\d{6}$/.test(code);
}
